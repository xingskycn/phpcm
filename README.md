PHP Cache Manager
=================

PHP Cache Mangaer - это менеджер кеша, созданный для упращения работы с кешированием в сложных, структурированных и высоконагруженных проектах.
В качестве backend для кеша используется memcached, в качестве интерфейса управления - расширение php.

# Features

Реализованные возможности:

1. Стандартные возможности memcached клиента (get/set/delete).
2. Dependency Cache - система зависимостей для сброса кеша.
3. Cache Replication - репликация кеша, для его отказоустойчивости

## Dependency Cache

Dependency Cache - возможность сброса большого количества ключей, через изменение одного ключа-зависимости. Ключ-зависимость, как и любой
другой ключ может содержать в себе полезные данные.

**Пример задачи**. Допустим у нас есть счетчики сообщений в ветке форума - "всего", "за месяц", "за день", "за 3 часа".
Эти счетчики закешированы по ключам "thread_1_all", "thread_1_month", "thread_1_day", "thread_1_3hour".
При добавлении сообщения в ветку форума, нам нужно сбрасывать все эти кеши.

**Пример использования**. С использованием Dependency Cache можно решить эту задачу просто. При расчете значений счетчиков (на моменте отображения страницы),
при условии отсутсвия их в кеше выполняется следующее:

    $mc->set("thread_1_all", $countAll);                                      //кеш общего счетчика "невечно"
    $mc->set("thread_1_month", $countMonth, "thread_1_all", 3600*24);         //кеш счетчика за месяц "на день", т.к. при наступлении следующего дня счетчик стоит пересчитать
    $mc->set("thread_1_day", $countDay, "thread_1_month", $diffToEndOfDay);   //кеш счетчика за день "до конца суток", т.к. при наступлении 00:00 счетчик стоит пересчитать
    $mc->set("thread_1_3hour", $count3hour, "thread_1_day", 3600);            //кеш счетчика за 3 чеса "на час", т.к. при наступелении следующего часа счетчик стоит обновить

Выше мы сохранили счетчики и выставили expire на случай, если новые сообщения добавляться не будутm но данные в кеше будут устаревать со временем. Так же мы сделали цепочку зависимостей:

    thread_1_day --- thread_1_day --- thread_1_month --- thread_1_all

Когда будет сброшен счетчик thread_1_day, счетчик thread_1_day тоже будет сброшен. Сброс счетчика thread_1_all сбрасывает все счетчики по цепочке.

Вот такой код мы выполняем при добавлении новго сообщения:

    $mc->set("thread_1_all", $newCountAll);

Т.к. новое количество будет на 1 больше, чем старое - это изменить значнеие ключа thread_1_day. Его изменение приведет к сбросу зависимых от него ключей (всех трех оставшихся по цепочке).

## Cache Replication

Cache Replication - реализация отказоустойчивого кеша с помощью репликации. Репликация настраивается в Runtime в конструкторе объекта класса Cm. Рассказать проще на примере.

Пример простого кеша без репликации:

    $mc = new Cm([ ['host'=>'127.0.0.1', 'port'=>11211] ]);

Пример разделенного между двумя memcached-серверами кеша без репликации:

    $mc = new Cm([ 
      [ 'host'=>'127.0.0.1', 'port'=>11211 ], //ShardA
      [ 'host'=>'127.0.0.1', 'port'=>11212 ], //ShardB
     ]);

Пример разделенного кеша с репликацией:

    $mc = new Cm(
      [ //shardA
        [ 'host'=>'192.168.1.29', 'port'=>11211 ], //ShardA, replica 1
        [ 'host'=>'192.168.2.29', 'port'=>11211 ], //ShardA, replica 2
      ],
      [ //shardB
        [ 'host'=>'192.168.1.30', 'port'=>11211 ], //ShardB, replica 1
        [ 'host'=>'192.168.2.30', 'port'=>11211 ], //ShardB, replica 2
        [ 'host'=>'192.168.3.30', 'port'=>11211 ], //ShardB, replica 3
      ]
    );

Не обязательно, чтобы все шарды были реплицированы:

    $mc = new Cm([
       [ 'host'=>'192.168.1.29', 'port'=>11211 ], //ShardA
       [
         [ 'host'=>'192.168.1.30', 'port'=>11211 ], //ShardB, replica 1
         [ 'host'=>'192.168.2.30', 'port'=>11211 ], //ShardB, replica 2
       ]
    ]);

Просытм конструированием объекта можно легко сделать отказоустойчивый кеш.

# Next Features

1. ReShard - возможность "мягкого" добавления новыйх нод memcached, без потери 1/n данных кеша.
2. Dependency Purge - возможность сброса кеша по сложной схеме зависимостей

# Ограничения

PHP Cache Manager и кеш, созданные с его использованием вносит некоторые ограничения в использования этого кеша:

1. В Memcached хранится не только *сам кеш* но и данные *меток для организации зависимостей (Dependency)*, так называемый DEP-заголовок. Из этого вытекает:
  1. Размер каждой записи в memcached будет больше минимум на N байт чем без использования PHP Cache Manager.
  2. Из за DEP-заголовка, невозможно использовать increment и decrement, реализованные внутри memcached, к данным сохраненным с помощью PHP Cache Manager.
  3. Использовать стандартный модуль nginx для работы с memcached напрямую, т.к. в nginx помимо сохраненного html будет отдаватся DEP-заголовок
2. Один php-объект PHP Cache Manager (new Cm()) может использовать до 255 шардов, каждый из которых может состоять из бОльшого числа реплик. Но:
  1. Мы не рекомендуем использовать 255 шардов, т.к. первые 25 с большой вероятностью не будут использованы.
  2. Мы крайне не рекомендуем конфигурировать объект Cm() с большим числом шардов, чем 255 - это может приводить к различным ошибкам, в том числе потере кеша, Segmentation Fault процессов php, Division By Zero в процессах php. **Мы защищаем это ограничение unit-тестами**, но лучше не пытатся так делать.
  3. Увеличение числа реплик до большого числа (>6) может привести к заметному замедлению операций set и delete. Это вызвано тем, что set и delete будут выполнятся на каждой реплике.
3. Использование расширения PHP - PHP Cache Manager приведет к повышению расхода CPU и RAM в рамках процесса PHP - до 4MB RAM на процесс. Это нормальное явление, т.к. PHP Cache Manager является исполняемым кодом и имеет свой overhead.

Это все ограничения, которые присудствуют в PHP Cache Manager. Других ограничений на его работу нет, и он не накладывает других ограничений на работу других сервисов.
